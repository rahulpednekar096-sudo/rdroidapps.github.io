<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>PPTX ‚Üí PDF ‚Äî RDroid Apps (Upgraded)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="../../css/style.css">

  <!-- JSZip for .pptx parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- jsPDF for PDF creation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>


</head>

<body>
  <!-- RDroidApps Header -->
  <header>
    <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
    <div class="logo">
      <img src="../../assets/my_brand_icon.png" alt="RDroid" />
      <div>RDroid <span>Apps</span></div>
    </div>
    <div class="nav-links">
      <a href="../../index.html" class="active">Home</a>
      <a href="../../apps.html">Apps</a>
      <a href="../../about.html">About</a>
      <a href="../../contact.html">Contact</a>
      <a href="../../windows-tools.html">Windows Tools</a>
    </div>
    <a href="../../auth/login.html" class="login-btn">üîë Login</a>
  </header>

  <!-- ===== DRAWER (UNCHANGED) ===== -->
  <nav id="drawer">
    <a href="../../index.html">üè† Home</a>
    <a href="../../apps.html">üì± Apps</a>
    <a href="../../favorites.html">‚≠ê Favorites</a>
    <a href="../../profile.html">üë§ Profile</a>
    <a href="../../about.html">‚ÑπÔ∏è About</a>
    <a href="../../contact.html">‚úâÔ∏è Contact</a>
    <a href="../../privacy-policy.html">üîí Privacy Policy</a>
  </nav>
  <section class="section">
    <h1>PPTX ‚Üí PDF (Upgraded)</h1>
    <p class="lead">Convert .pptx into a PDF. Best-effort extraction: uses embedded slide images when available;
      otherwise a text-based slide image is generated.</p>

    <div class="drop" id="dropArea">Drop PPTX here or <button class="btn" id="pickBtn">Choose file</button>
      <input type="file" id="fileInput" accept=".pptx" style="display:none" />
    </div>

    <div class="controls">
      <div class="control">
        <label>PDF Page size</label>
        <select id="pageSize">
          <option value="a4" selected>A4</option>
          <option value="letter">Letter</option>
        </select>
        <label style="margin-top:8px">Orientation</label>
        <select id="orientation">
          <option value="portrait">Portrait</option>
          <option value="landscape" selected>Landscape</option>
        </select>
      </div>

      <div class="control">
        <label>Options</label>
        <label><input type="checkbox" id="extractImages" checked> Use embedded slide images (if present)</label>
        <label><input type="checkbox" id="includeText" checked> Render slide text (fallback)</label>
      </div>

      <div class="control">
        <label>Output name</label>
        <input type="text" id="outName" value="presentation.pdf"
          style="width:100%;padding:8px;border-radius:6px;background:#090b0c;color:#e6eef0;border:1px solid #222" />
      </div>
    </div>

    <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
      <button class="btn-primary" id="convertBtn">Convert to PDF</button>
      <button class="btn" id="clearBtn">Clear</button>
      <div style="margin-left:auto" id="sizeInfo"></div>
    </div>

    <div class="progress" id="progressWrap">
      <div class="bar" id="progressBar"></div>
    </div>
    <div id="thumbs" class="thumbs"></div>
    <pre id="log" class="log">Ready.</pre>
    <div id="downloadArea" style="margin-top:12px"></div>
  </section>
  <footer style="margin-top:14px;color:#9fbfb0">¬© 2025 RDroid Apps ‚Äî PPT Tools</footer>
  <script>
    // Drawer toggle
    function toggleMenu() {
      document.getElementById("drawer").classList.toggle("open");
    }
    const fileInput = document.getElementById('fileInput');
    const pickBtn = document.getElementById('pickBtn');
    const dropArea = document.getElementById('dropArea');
    const convertBtn = document.getElementById('convertBtn');
    const clearBtn = document.getElementById('clearBtn');
    const thumbs = document.getElementById('thumbs');
    const logEl = document.getElementById('log');
    const progressWrap = document.getElementById('progressWrap');
    const progressBar = document.getElementById('progressBar');
    const extractImagesCheckbox = document.getElementById('extractImages');
    const includeTextCheckbox = document.getElementById('includeText');
    const outName = document.getElementById('outName');
    const pageSizeSel = document.getElementById('pageSize');
    const orientationSel = document.getElementById('orientation');
    const downloadArea = document.getElementById('downloadArea');
    let zipFile = null;
    let slides = []; // {id, imageBlob (optional), text (optional), thumbDataUrl, selected}

    function log(msg) { logEl.textContent += "\\n" + msg; logEl.scrollTop = logEl.scrollHeight; }
    function setProgress(p) { progressWrap.style.display = (p >= 0 ? 'block' : 'none'); progressBar.style.width = (p * 100).toFixed(1) + '%'; }

    pickBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.classList.add('dragover'); });
    dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
    dropArea.addEventListener('drop', e => { e.preventDefault(); dropArea.classList.remove('dragover'); if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });

    async function handleFile(file) {
      if (!file) return;
      clearAll();
      log('Loading PPTX: ' + file.name);
      const arrayBuffer = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);
      zipFile = zip;
      // try to extract embedded media (images)
      // slides usually have /ppt/slides/slide1.xml ... and images in /ppt/media
      const mediaFiles = Object.keys(zip.files).filter(p => p.startsWith('ppt/media/'));
      const slideFiles = Object.keys(zip.files).filter(p => p.startsWith('ppt/slides/slide') && p.endsWith('.xml')).sort();
      log('Found ' + slideFiles.length + ' slide xml files, ' + mediaFiles.length + ' media files.');
      // basic mapping: if media names contain slide numbers or are referenced in slide xml, attempt to map
      slides = [];
      for (let i = 0; i < slideFiles.length; i++) {
        const slidePath = slideFiles[i];
        const slideXml = await zip.files[slidePath].async('string');
        // try to find image references inside slide xml: r:embed="rIdX" then find relationships in /ppt/slides/_rels/slideN.xml.rels
        let imageBlob = null;
        let thumbData = null;
        try {
          const relPath = slidePath.replace('ppt/slides/', 'ppt/slides/_rels/') + '.rels';
          if (zip.files[relPath]) {
            const relXml = await zip.files[relPath].async('string');
            // find target like ../media/image1.png
            const m = relXml.match(/Target="(.*?)"/g);
            if (m) {
              for (const t of m) {
                const tgt = t.replace(/Target="|"$/g, '');
                // normalize path
                const p = tgt.replace('../', 'ppt/');
                if (zip.files[p]) {
                  const b = await zip.files[p].async('blob');
                  imageBlob = b;
                  break;
                }
              }
            }
          }
        } catch (err) { /* ignore */ }

        // If no embedded image found, attempt to create a text-based thumbnail by extracting text nodes
        let textContent = '';
        if (includeTextCheckbox.checked) {
          try {
            // crude text extraction: find text between <a:t>...</a:t>
            const matches = slideXml.match(/<a:t[^>]*>([\s\S]*?)<\/a:t>/g);
            if (matches) {
              textContent = matches.map(x => x.replace(/<.*?>/g, '').trim()).join(' ').replace(/\s+/g, ' ');
            } else {
              // fallback to nodes with <p:txBody> content
              const m2 = slideXml.replace(/<.*?>/g, ' ').replace(/\s+/g, ' ').trim();
              textContent = m2.slice(0, 800); // limit
            }
          } catch (e) { }
        }

        // create thumbnail: if image exists, use it; else create canvas with text
        if (imageBlob) {
          thumbData = await blobToDataURL(imageBlob);
        } else {
          // generate simple canvas
          const c = document.createElement('canvas');
          c.width = 1280; c.height = 720;
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, c.width, c.height);
          ctx.fillStyle = '#111';
          ctx.font = '24px sans-serif';
          const txt = textContent || `Slide ${i + 1}`;
          wrapText(ctx, txt, 40, 60, c.width - 80, 26);
          thumbData = c.toDataURL('image/png', 0.8);
          // also prepare image blob
          const blob = await new Promise(r => c.toBlob(r, 'image/png', 0.9));
          imageBlob = blob;
        }

        slides.push({ index: i + 1, slidePath, imageBlob, text: textContent, thumb: thumbData, selected: true });
        renderThumbs();
        await briefYield(20);
      }
      log('Prepared ' + slides.length + ' slides for export.');
    }

    function renderThumbs() {
      thumbs.innerHTML = '';
      slides.forEach((s, idx) => {
        const d = document.createElement('div');
        d.className = 'thumb';
        d.innerHTML = `<img src="${s.thumb}"><div style="margin-top:6px;color:#9fbfb0">Slide ${s.index}</div>
        <div style="margin-top:6px"><label><input type="checkbox" data-idx="${idx}" ${s.selected ? 'checked' : ''}> Select</label></div>
        <div style="margin-top:8px"><button class="btn" data-idx="${idx}" data-act="up">‚Üë</button><button class="btn" data-idx="${idx}" data-act="down">‚Üì</button><button class="btn" data-idx="${idx}" data-act="remove">‚úï</button></div>`;
        thumbs.appendChild(d);
      });
      // bind
      thumbs.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.addEventListener('change', e => {
          slides[e.target.dataset.idx].selected = e.target.checked;
        });
      });
      thumbs.querySelectorAll('button').forEach(b => {
        b.addEventListener('click', e => {
          const idx = parseInt(e.target.dataset.idx);
          const act = e.target.dataset.act;
          if (act === 'up' && idx > 0) { moveSlide(idx, idx - 1); }
          if (act === 'down' && idx < slides.length - 1) { moveSlide(idx, idx + 1); }
          if (act === 'remove') { slides.splice(idx, 1); renderThumbs(); }
        });
      });
    }

    function moveSlide(from, to) { const tmp = slides.splice(from, 1)[0]; slides.splice(to, 0, tmp); renderThumbs(); }

    async function blobToDataURL(b) { return new Promise(r => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.readAsDataURL(b); }); }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }

    convertBtn.addEventListener('click', async () => {
      if (!slides.length) { alert('Load a PPTX first'); return; }
      const selectedSlides = slides.filter(s => s.selected);
      if (!selectedSlides.length) { alert('Select at least one slide'); return; }

      convertBtn.disabled = true;
      setProgress(0);
      log('Creating PDF...');

      const { jsPDF } = window.jspdf;
      // determine page size
      let pdf;
      const pageSize = pageSizeSel.value;
      const orient = orientationSel.value;
      const unit = 'mm';
      const pageFormats = { a4: { w: 210, h: 297 }, letter: { w: 216, h: 279 } };
      const dims = pageFormats[pageSize] || pageFormats.a4;
      const pw = orient === 'landscape' ? dims.h : dims.w;
      const ph = orient === 'landscape' ? dims.w : dims.h;
      pdf = new jsPDF({ unit, format: [pw, ph] });

      for (let i = 0; i < selectedSlides.length; i++) {
        const s = selectedSlides[i];
        log(`Processing slide ${s.index}...`);
        // imageBlob -> DataURL
        let dataURL;
        if (s.imageBlob) {
          dataURL = await blobToDataURL(s.imageBlob);
        } else {
          // should not happen; fallback to blank
          const c = document.createElement('canvas'); c.width = 1280; c.height = 720;
          const ctx = c.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, c.width, c.height);
          dataURL = c.toDataURL('image/png');
        }
        // Add image filling page while maintaining aspect
        // convert px->mm (1px ‚âà 0.264583 mm)
        const img = await loadImage(dataURL);
        const pxToMm = 0.264583;
        const imgWmm = img.width * pxToMm;
        const imgHmm = img.height * pxToMm;
        const maxW = pw, maxH = ph;
        const ratio = Math.min(maxW / imgWmm, maxH / imgHmm);
        const drawW = imgWmm * ratio;
        const drawH = imgHmm * ratio;
        const x = (pw - drawW) / 2;
        const y = (ph - drawH) / 2;
        if (i > 0) pdf.addPage([pw, ph], orient);
        pdf.addImage(dataURL, 'JPEG', x, y, drawW, drawH, undefined, 'FAST');
        setProgress((i + 1) / selectedSlides.length);
        await briefYield(50);
      }

      // finalize
      const blob = pdf.output('blob');
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = outName.value || 'presentation.pdf';
      a.textContent = 'Download PDF';
      a.className = 'btn btn-primary';
      downloadArea.innerHTML = '';
      downloadArea.appendChild(a);
      log('Done ‚Äî PDF ready.');
      setProgress(-1);
      convertBtn.disabled = false;
    });

    function loadImage(src) { return new Promise((res, rej) => { const img = new Image(); img.onload = () => res(img); img.onerror = rej; img.src = src; }); }
    function briefYield(ms = 20) { return new Promise(r => setTimeout(r, ms)); }

    clearBtn.addEventListener('click', () => { slides = []; zipFile = null; thumbs.innerHTML = ''; downloadArea.innerHTML = ''; logEl.textContent = 'Ready.'; setProgress(-1); });
  </script>
</body>

</html>
