<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>PPTX → PDF — RDroid Apps (Upgraded)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description"
    content="Convert .pptx into a PDF. Best-effort extraction: uses embedded slide images when available; otherwise a text-based slide image is generated." />
  <meta name="keywords"
    content="pptx to pdf, convert ppt to pdf, powerpoint to pdf, pptx converter, pdf conversion, pdf tools, rdroid apps" />

  <link rel="stylesheet" href="../../css/style.css">

  <!-- JSZip for .pptx parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- jsPDF for PDF creation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Include jQuery for load function -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>

<body>
  <!-- HEADER (loaded from external file) -->
  <div id="header-container"></div>

  <!-- TOOLS QUICK LINKS (loaded from external file) -->
  <div id="tools-links-container"></div>

  <!-- MENU DRAWER (loaded from external file) -->
  <div id="menu-drawer-container"></div>

  <!-- Load all components -->
  <script>
    $(function () {
      $("#header-container").load("../../components/header.html");
      $("#menu-drawer-container").load("../../components/menu-drawer.html");
      $("#tools-links-container").load("../../components/pdf-tools-quick-links.html");
      $("#footer-container").load("../../components/footer.html");
    });
  </script>

  <section class="section">
    <h1>PPTX → PDF (Upgraded)</h1>
    <p class="lead">Convert .pptx into a PDF. Best-effort extraction: uses embedded slide images when available;
      otherwise a text-based slide image is generated.</p>

    <div class="drop" id="dropArea">Drop PPTX here or <button class="btn" id="pickBtn">Choose file</button>
      <input type="file" id="fileInput" accept=".pptx" style="display:none" />
    </div>

    <div class="controls">
      <div class="control">
        <label>PDF Page size</label>
        <select id="pageSize">
          <option value="a4" selected>A4</option>
          <option value="letter">Letter</option>
        </select>
        <label style="margin-top:8px">Orientation</label>
        <select id="orientation">
          <option value="portrait">Portrait</option>
          <option value="landscape" selected>Landscape</option>
        </select>
      </div>

      <div class="control">
        <label>Options</label>
        <label><input type="checkbox" id="extractImages" checked> Use embedded slide images (if present)</label>
        <label><input type="checkbox" id="includeText" checked> Render slide text (fallback)</label>
      </div>

      <div class="control">
        <label>Output name</label>
        <input type="text" id="outName" value="presentation.pdf"
          style="width:100%;padding:8px;border-radius:6px;background:#090b0c;color:#e6eef0;border:1px solid #222" />
      </div>
    </div>

    <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
      <button class="btn btn-primary" id="convertBtn">Convert ppt to PDF</button>
      <button class="btn" id="clearBtn">Clear</button>
      <div style="margin-left:auto" id="sizeInfo"></div>
    </div>

    <div class="progress" id="progressWrap">
      <div class="bar" id="progressBar"></div>
    </div>
    <div id="thumbs" class="thumbs"></div>
    <pre id="log" class="log">Ready.</pre>
    <div id="downloadArea" style="margin-top:12px"></div>
    <!-- SEO Content -->
    <pre id="log">Ready.</pre>
    <div id="warning" style="color:#ffb199; margin-top:8px"></div>
    <hr style="margin:32px 0">

    <section class="seo-content">
      <h2>PPTX to PDF Converter — RDroidApps Pro</h2>

      <p>
        Looking to convert your PowerPoint presentations (PPTX) into PDF format? Our PPTX to PDF converter allows you to
        easily transform your slides into a professional PDF document. Whether you're sharing presentations or archiving
        them, this tool provides a fast and reliable solution.
      </p>

      <h3>Key Features:</h3>
      <ul>
        <li><strong>Slide Image Extraction:</strong> If your presentation contains embedded images, they will be
          extracted and included in the PDF for high-quality output.</li>
        <li><strong>Text Rendering:</strong> If embedded images are not available, the tool will generate a text-based
          representation of each slide.</li>
        <li><strong>Customizable Page Settings:</strong> Choose from standard page sizes like A4 and Letter, or set
          custom dimensions. Adjust margins and orientation to suit your needs.</li>
        <li><strong>User-Friendly Interface:</strong> Our intuitive design makes it easy for users of all skill levels
          to convert PPTX files to PDF quickly and efficiently.</li>
      </ul>
      <h3>How to Use the PPTX to PDF Converter:</h3>
      <ol>
        <li><strong>Upload Your PPTX:</strong> Click on the "Choose file" button or drag and drop your PPTX document
          into the designated area.</li>
        <li><strong>Select Page Settings:</strong> Choose your desired page size and orientation from the available
          options.</li>
        <li><strong>Choose Options:</strong> Decide whether to extract embedded slide images and/or render slide text.
        </li>
        <li><strong>Convert:</strong> Click the "Convert ppt to PDF" button to start the conversion process. The
          converted PDF will appear in the download area.</li>
        <li><strong>Download:</strong> Once the conversion is complete, click the download button to save your PDF
          document.</li>
      </ol>
      <p>
        Our PPTX to PDF converter is perfect for students, professionals, and anyone who needs to share or archive
        presentations in a widely accessible format. Enjoy high-quality conversions with just a few clicks!
      </p>

      <p>
        Try our PPTX to PDF converter today and experience the convenience of turning your presentations into
        professional PDF documents in just a few clicks!
      </p>


    </section>
    <!-- FOOTER (loaded from external file) -->
    <div id="footer-container"></div>
    <script>
      // Drawer toggle
      function toggleMenu() {
        document.getElementById("drawer").classList.toggle("open");
      }
      const fileInput = document.getElementById('fileInput');
      const pickBtn = document.getElementById('pickBtn');
      const dropArea = document.getElementById('dropArea');
      const convertBtn = document.getElementById('convertBtn');
      const clearBtn = document.getElementById('clearBtn');
      const thumbs = document.getElementById('thumbs');
      const logEl = document.getElementById('log');
      const progressWrap = document.getElementById('progressWrap');
      const progressBar = document.getElementById('progressBar');
      const extractImagesCheckbox = document.getElementById('extractImages');
      const includeTextCheckbox = document.getElementById('includeText');
      const outName = document.getElementById('outName');
      const pageSizeSel = document.getElementById('pageSize');
      const orientationSel = document.getElementById('orientation');
      const downloadArea = document.getElementById('downloadArea');
      let zipFile = null;
      let slides = []; // {id, imageBlob (optional), text (optional), thumbDataUrl, selected}

      function log(msg) { logEl.textContent += "\\n" + msg; logEl.scrollTop = logEl.scrollHeight; }
      function setProgress(p) { progressWrap.style.display = (p >= 0 ? 'block' : 'none'); progressBar.style.width = (p * 100).toFixed(1) + '%'; }

      pickBtn.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

      dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.classList.add('dragover'); });
      dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
      dropArea.addEventListener('drop', e => { e.preventDefault(); dropArea.classList.remove('dragover'); if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });

      async function handleFile(file) {
        if (!file) return;
        clearAll();
        log('Loading PPTX: ' + file.name);
        const arrayBuffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        zipFile = zip;
        // try to extract embedded media (images)
        // slides usually have /ppt/slides/slide1.xml ... and images in /ppt/media
        const mediaFiles = Object.keys(zip.files).filter(p => p.startsWith('ppt/media/'));
        const slideFiles = Object.keys(zip.files).filter(p => p.startsWith('ppt/slides/slide') && p.endsWith('.xml')).sort();
        log('Found ' + slideFiles.length + ' slide xml files, ' + mediaFiles.length + ' media files.');
        // basic mapping: if media names contain slide numbers or are referenced in slide xml, attempt to map
        slides = [];
        for (let i = 0; i < slideFiles.length; i++) {
          const slidePath = slideFiles[i];
          const slideXml = await zip.files[slidePath].async('string');
          // try to find image references inside slide xml: r:embed="rIdX" then find relationships in /ppt/slides/_rels/slideN.xml.rels
          let imageBlob = null;
          let thumbData = null;
          try {
            const relPath = slidePath.replace('ppt/slides/', 'ppt/slides/_rels/') + '.rels';
            if (zip.files[relPath]) {
              const relXml = await zip.files[relPath].async('string');
              // find target like ../media/image1.png
              const m = relXml.match(/Target="(.*?)"/g);
              if (m) {
                for (const t of m) {
                  const tgt = t.replace(/Target="|"$/g, '');
                  // normalize path
                  const p = tgt.replace('../', 'ppt/');
                  if (zip.files[p]) {
                    const b = await zip.files[p].async('blob');
                    imageBlob = b;
                    break;
                  }
                }
              }
            }
          } catch (err) { /* ignore */ }

          // If no embedded image found, attempt to create a text-based thumbnail by extracting text nodes
          let textContent = '';
          if (includeTextCheckbox.checked) {
            try {
              // crude text extraction: find text between <a:t>...</a:t>
              const matches = slideXml.match(/<a:t[^>]*>([\s\S]*?)<\/a:t>/g);
              if (matches) {
                textContent = matches.map(x => x.replace(/<.*?>/g, '').trim()).join(' ').replace(/\s+/g, ' ');
              } else {
                // fallback to nodes with <p:txBody> content
                const m2 = slideXml.replace(/<.*?>/g, ' ').replace(/\s+/g, ' ').trim();
                textContent = m2.slice(0, 800); // limit
              }
            } catch (e) { }
          }

          // create thumbnail: if image exists, use it; else create canvas with text
          if (imageBlob) {
            thumbData = await blobToDataURL(imageBlob);
          } else {
            // generate simple canvas
            const c = document.createElement('canvas');
            c.width = 1280; c.height = 720;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, c.width, c.height);
            ctx.fillStyle = '#111';
            ctx.font = '24px sans-serif';
            const txt = textContent || `Slide ${i + 1}`;
            wrapText(ctx, txt, 40, 60, c.width - 80, 26);
            thumbData = c.toDataURL('image/png', 0.8);
            // also prepare image blob
            const blob = await new Promise(r => c.toBlob(r, 'image/png', 0.9));
            imageBlob = blob;
          }

          slides.push({ index: i + 1, slidePath, imageBlob, text: textContent, thumb: thumbData, selected: true });
          renderThumbs();
          await briefYield(20);
        }
        log('Prepared ' + slides.length + ' slides for export.');
      }

      function renderThumbs() {
        thumbs.innerHTML = '';
        slides.forEach((s, idx) => {
          const d = document.createElement('div');
          d.className = 'thumb';
          d.innerHTML = `<img src="${s.thumb}"><div style="margin-top:6px;color:#9fbfb0">Slide ${s.index}</div>
        <div style="margin-top:6px"><label><input type="checkbox" data-idx="${idx}" ${s.selected ? 'checked' : ''}> Select</label></div>
        <div style="margin-top:8px"><button class="btn" data-idx="${idx}" data-act="up">↑</button><button class="btn" data-idx="${idx}" data-act="down">↓</button><button class="btn" data-idx="${idx}" data-act="remove">✕</button></div>`;
          thumbs.appendChild(d);
        });
        // bind
        thumbs.querySelectorAll('input[type=checkbox]').forEach(cb => {
          cb.addEventListener('change', e => {
            slides[e.target.dataset.idx].selected = e.target.checked;
          });
        });
        thumbs.querySelectorAll('button').forEach(b => {
          b.addEventListener('click', e => {
            const idx = parseInt(e.target.dataset.idx);
            const act = e.target.dataset.act;
            if (act === 'up' && idx > 0) { moveSlide(idx, idx - 1); }
            if (act === 'down' && idx < slides.length - 1) { moveSlide(idx, idx + 1); }
            if (act === 'remove') { slides.splice(idx, 1); renderThumbs(); }
          });
        });
      }

      function moveSlide(from, to) { const tmp = slides.splice(from, 1)[0]; slides.splice(to, 0, tmp); renderThumbs(); }

      async function blobToDataURL(b) { return new Promise(r => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.readAsDataURL(b); }); }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        for (let n = 0; n < words.length; n++) {
          const testLine = line + words[n] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;
          if (testWidth > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, y);
      }

      convertBtn.addEventListener('click', async () => {
        if (!slides.length) { alert('Load a PPTX first'); return; }
        const selectedSlides = slides.filter(s => s.selected);
        if (!selectedSlides.length) { alert('Select at least one slide'); return; }

        convertBtn.disabled = true;
        setProgress(0);
        log('Creating PDF...');

        const { jsPDF } = window.jspdf;
        // determine page size
        let pdf;
        const pageSize = pageSizeSel.value;
        const orient = orientationSel.value;
        const unit = 'mm';
        const pageFormats = { a4: { w: 210, h: 297 }, letter: { w: 216, h: 279 } };
        const dims = pageFormats[pageSize] || pageFormats.a4;
        const pw = orient === 'landscape' ? dims.h : dims.w;
        const ph = orient === 'landscape' ? dims.w : dims.h;
        pdf = new jsPDF({ unit, format: [pw, ph] });

        for (let i = 0; i < selectedSlides.length; i++) {
          const s = selectedSlides[i];
          log(`Processing slide ${s.index}...`);
          // imageBlob -> DataURL
          let dataURL;
          if (s.imageBlob) {
            dataURL = await blobToDataURL(s.imageBlob);
          } else {
            // should not happen; fallback to blank
            const c = document.createElement('canvas'); c.width = 1280; c.height = 720;
            const ctx = c.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, c.width, c.height);
            dataURL = c.toDataURL('image/png');
          }
          // Add image filling page while maintaining aspect
          // convert px->mm (1px ≈ 0.264583 mm)
          const img = await loadImage(dataURL);
          const pxToMm = 0.264583;
          const imgWmm = img.width * pxToMm;
          const imgHmm = img.height * pxToMm;
          const maxW = pw, maxH = ph;
          const ratio = Math.min(maxW / imgWmm, maxH / imgHmm);
          const drawW = imgWmm * ratio;
          const drawH = imgHmm * ratio;
          const x = (pw - drawW) / 2;
          const y = (ph - drawH) / 2;
          if (i > 0) pdf.addPage([pw, ph], orient);
          pdf.addImage(dataURL, 'JPEG', x, y, drawW, drawH, undefined, 'FAST');
          setProgress((i + 1) / selectedSlides.length);
          await briefYield(50);
        }

        // finalize
        const blob = pdf.output('blob');
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = outName.value || 'presentation.pdf';
        a.textContent = 'Download PDF';
        a.className = 'btn btn-primary';
        downloadArea.innerHTML = '';
        downloadArea.appendChild(a);
        log('Done — PDF ready.');
        setProgress(-1);
        convertBtn.disabled = false;
      });

      function loadImage(src) { return new Promise((res, rej) => { const img = new Image(); img.onload = () => res(img); img.onerror = rej; img.src = src; }); }
      function briefYield(ms = 20) { return new Promise(r => setTimeout(r, ms)); }

      clearBtn.addEventListener('click', () => { slides = []; zipFile = null; thumbs.innerHTML = ''; downloadArea.innerHTML = ''; logEl.textContent = 'Ready.'; setProgress(-1); });
    </script>

</body>

</html>
