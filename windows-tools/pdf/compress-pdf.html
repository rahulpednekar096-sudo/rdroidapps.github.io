<!DOCTYPE html>
<html lang="mr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compress PDF ‚Äî Heavy (Upgraded) ‚Äì RDroid Apps</title>
  <link rel="stylesheet" href="../../css/style.css">

  <!-- pdf.js + pdf-lib + tesseract (optional) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
</head>

<body>
  <!-- RDroidApps Header -->
  <header>
    <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
    <div class="logo">
      <img src="../../assets/my_brand_icon.png" alt="RDroid Logo" />
      <div>RDroid <span>Apps</span></div>
    </div>
    <a href="/auth/login.html" class="login-btn">üîë Login</a>
  </header>

  <!-- Drawer Navigation -->
  <nav id="drawer">
    <a href="../../index.html">üè† Home</a>
    <a href="../../apps.html">üì± Apps</a>
    <a href="../../favorites.html">‚≠ê Favorites</a>
    <a href="../../profile.html">üë§ Profile</a>
    <a href="../../about.html">‚ÑπÔ∏è About</a>
    <a href="../../contact.html">‚úâÔ∏è Contact</a>
    <a href="../../privacy-policy.html">üîí Privacy Policy</a>
  </nav>
  <section class="tool-section">
    <div class="card">
      <h1>Compress PDF ‚Äî Heavy (Upgraded)</h1>
      <p class="note">Pages are rasterized to JPEG images and re-packed. Great for large image-heavy PDFs. Text will NOT
        remain selectable. Use OCR summary if you need extracted text separately.</p>

      <label class="drop" id="dropArea">Drop PDF here or <button class="btn btn-ghost" id="pickBtn">Choose
          file</button></label>
      <input type="file" id="fileInput" accept="application/pdf" />

      <div class="row">
        <div class="col">
          <label class="small">Target scale</label>
          <select id="scaleSelect">
            <option value="0.25">Very small (0.25√ó) ‚Äî max reduction</option>
            <option value="0.5" selected>Medium (0.5√ó) ‚Äî balanced</option>
            <option value="0.75">High quality (0.75√ó)</option>
            <option value="1">Original size (1√ó)</option>
          </select>
        </div>

        <div class="col">
          <label class="small">JPEG quality (%)</label>
          <input type="range" id="jpegQ" min="10" max="95" value="70">
          <div class="meta" id="jpegVal">Quality: 70%</div>
        </div>

        <div class="col">
          <label class="small">Max pages to process (set 0 for all)</label>
          <input type="number" id="maxPages" min="0" value="0" />
        </div>

        <div class="col">
          <label class="small">Options</label>
          <div style="display:flex;gap:8px;flex-direction:column">
            <label><input type="checkbox" id="optPreview" checked> Show preview thumbnails</label>
            <label><input type="checkbox" id="optOCR"> Include OCR text summary (slow)</label>
          </div>
        </div>
      </div>

      <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
        <button class="btn btn-primary" id="startBtn">Compress Now</button>
        <button class="btn btn-ghost" id="cancelBtn" style="display:none">Cancel</button>
        <a id="downloadLink" class="btn" style="display:none"></a>
        <div style="margin-left:auto" id="sizeInfo"></div>
      </div>

      <div class="progress" id="progressWrap" style="display:none">
        <div class="bar" id="progressBar"></div>
      </div>

      <div id="preview" style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap"></div>

      <pre id="log">Ready.</pre>
      <div id="warning" style="color:#ffb199; margin-top:8px"></div>
    </div>

    <footer>¬© 2025 RDroid Apps ‚Äî PDF Tools</footer>
  </section>

  <script>
    // Drawer toggle
    function toggleMenu() {
      document.getElementById("drawer").classList.toggle("open");
    }
    /* Upgraded compressor
       - Based on previous implementation. Reference: original assistant version. :contentReference[oaicite:1]{index=1}
       - Enhancements: drag/drop, cancel, preview, OCR summary option, safer page loop with yields.
    */

    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    const pickBtn = document.getElementById('pickBtn');
    const startBtn = document.getElementById('startBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const scaleSelect = document.getElementById('scaleSelect');
    const jpegQ = document.getElementById('jpegQ');
    const jpegVal = document.getElementById('jpegVal');
    const maxPagesInput = document.getElementById('maxPages');
    const progressWrap = document.getElementById('progressWrap');
    const progressBar = document.getElementById('progressBar');
    const logEl = document.getElementById('log');
    const downloadLink = document.getElementById('downloadLink');
    const previewEl = document.getElementById('preview');
    const optPreview = document.getElementById('optPreview');
    const optOCR = document.getElementById('optOCR');
    const sizeInfo = document.getElementById('sizeInfo');
    const warningEl = document.getElementById('warning');

    let controller = { cancel: false };
    let currentFile = null;

    jpegQ.addEventListener('input', () => jpegVal.textContent = `Quality: ${jpegQ.value}%`);
    pickBtn.addEventListener('click', () => fileInput.click());

    dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.style.borderColor = '#0aa37f'; });
    dropArea.addEventListener('dragleave', () => dropArea.style.borderColor = '#202426');
    dropArea.addEventListener('drop', async (e) => { e.preventDefault(); dropArea.style.borderColor = '#202426'; if (e.dataTransfer.files.length) { fileInput.files = e.dataTransfer.files; handleFileSelected(); } });

    fileInput.addEventListener('change', handleFileSelected);

    function log(msg) { logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }
    function clearLog() { logEl.textContent = ''; }
    function setProgress(p) { progressWrap.style.display = p >= 0 ? 'block' : 'none'; progressBar.style.width = (p * 100).toFixed(1) + '%'; }
    function resetUI() { cancelBtn.style.display = 'none'; startBtn.style.display = 'inline-block'; downloadLink.style.display = 'none'; previewEl.innerHTML = ''; sizeInfo.textContent = ''; warningEl.textContent = ''; }

    function handleFileSelected() {
      currentFile = fileInput.files[0];
      if (currentFile) {
        clearLog();
        log(`Selected: ${currentFile.name} ‚Äî ${(currentFile.size / 1024).toFixed(1)} KB`);
        sizeInfo.textContent = '';
        downloadLink.style.display = 'none';
        previewEl.innerHTML = '';
      }
    }

    // tiny helper to yield to UI / avoid freeze
    async function briefYield(ms = 20) { return new Promise(r => setTimeout(r, ms)); }

    startBtn.addEventListener('click', async () => {
      if (!currentFile) return alert('‡§ï‡•É‡§™‡§Ø‡§æ PDF ‡§®‡§ø‡§µ‡§°‡§æ.');
      controller.cancel = false;
      cancelBtn.style.display = 'inline-block';
      startBtn.style.display = 'none';
      clearLog();
      previewEl.innerHTML = '';
      downloadLink.style.display = 'none';
      sizeInfo.textContent = '';
      warningEl.textContent = '';

      const scaleFactor = parseFloat(scaleSelect.value);
      const quality = parseInt(jpegQ.value) / 100;
      const maxPages = Math.max(0, parseInt(maxPagesInput.value) || 0); // 0 => all
      const doPreview = optPreview.checked;
      const doOCR = optOCR.checked;

      log(`Starting compression ‚Äî scale ${scaleFactor}√ó, JPEG quality ${Math.round(quality * 100)}%`);
      setProgress(0);

      // Safety: warn for very large files
      if (currentFile.size > 50 * 1024 * 1024) {
        warningEl.textContent = 'Warning: large file (>50MB). This may be slow and may use a lot of memory.';
      }

      // load pdf.js
      if (!window.pdfjsLib) { alert('pdf.js not loaded'); resetUI(); return; }
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      // load file
      const arrayBuffer = await currentFile.arrayBuffer();
      const pdfData = new Uint8Array(arrayBuffer);
      let pdf;
      try {
        pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
      } catch (e) {
        log('Failed to parse PDF: ' + e.message);
        resetUI();
        return;
      }

      const totalPages = pdf.numPages;
      log(`Input pages: ${totalPages}`);

      const pagesToProcess = (maxPages > 0) ? Math.min(maxPages, totalPages) : totalPages;

      // create new pdf
      const newPdf = await PDFLib.PDFDocument.create();
      let ocrTexts = [];

      for (let i = 1; i <= pagesToProcess; i++) {
        if (controller.cancel) { log('Cancelled by user'); break; }
        try {
          log(`Rendering page ${i}/${pagesToProcess} ...`);
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 1.0 });
          const renderWidth = Math.max(1, Math.round(viewport.width * scaleFactor));
          const renderHeight = Math.max(1, Math.round(viewport.height * scaleFactor));
          const canvas = document.createElement('canvas');
          canvas.width = renderWidth;
          canvas.height = renderHeight;
          const ctx = canvas.getContext('2d');

          // render
          const renderContext = { canvasContext: ctx, viewport: page.getViewport({ scale: scaleFactor }) };
          await page.render(renderContext).promise;

          // optional preview thumbnail
          if (doPreview) {
            const thumb = document.createElement('img');
            thumb.style.maxWidth = '120px'; thumb.style.borderRadius = '6px';
            thumb.src = canvas.toDataURL('image/jpeg', Math.max(0.1, quality));
            previewEl.appendChild(thumb);
          }

          // optional OCR of page (summary) ‚Äî slow
          if (doOCR) {
            try {
              log(`OCR page ${i} ... (this may be slow)`);
              const worker = Tesseract.createWorker({ logger: m => { } });
              await worker.load(); await worker.loadLanguage('eng'); await worker.initialize('eng');
              const { data: { text } } = await worker.recognize(canvas);
              ocrTexts.push(`--- Page ${i} ---\n` + (text.trim() || '[no text detected]') + '\n');
              await worker.terminate();
            } catch (ocrErr) {
              log('OCR failed for page ' + i + ': ' + ocrErr.message);
            }
          }

          // convert canvas to JPEG blob
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
          const arrayBuf = await blob.arrayBuffer();
          const jpgBytes = new Uint8Array(arrayBuf);

          // embed and add page
          const imgEmbed = await newPdf.embedJpg(jpgBytes);
          const imgDims = imgEmbed.scale(1);
          const pdfPage = newPdf.addPage([imgDims.width, imgDims.height]);
          pdfPage.drawImage(imgEmbed, { x: 0, y: 0, width: imgDims.width, height: imgDims.height });

          // progress update
          setProgress(i / pagesToProcess);
          await briefYield(30); // yield to UI and GC
          // free canvas memory
          ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
        } catch (pageErr) {
          log('Error processing page ' + i + ': ' + (pageErr.message || pageErr));
        }
      }

      // if OCR texts exist and user wanted summary, add as last page (text)
      if (ocrTexts.length && !controller.cancel) {
        try {
          const textDoc = newPdf.addPage([595, 842]); // A4-ish
          const combined = ocrTexts.join('\n\n');
          textDoc.drawText('OCR Summary (automatically extracted text):', { x: 20, y: textDoc.getHeight() - 40, size: 12, color: PDFLib.rgb(0.9, 0.9, 0.9) });
          // split text into lines
          const lines = combined.split('\n');
          let cursorY = textDoc.getHeight() - 60;
          const lineHeight = 12;
          for (const line of lines) {
            if (cursorY < 40) {
              // add new page
              cursorY = textDoc.getHeight() - 40;
            }
            textDoc.drawText(line, { x: 20, y: cursorY, size: 10, color: PDFLib.rgb(0.85, 0.85, 0.85) });
            cursorY -= lineHeight;
          }
          log('OCR summary added as last page.');
        } catch (e) {
          log('Failed to append OCR summary: ' + e.message);
        }
      }

      if (controller.cancel) {
        resetUI(); setProgress(-1); log('Operation cancelled ‚Äî no file produced.'); return;
      }

      log('Finalizing PDF (this may take some seconds)...');
      try {
        const pdfBytes = await newPdf.save();
        const outBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        const outUrl = URL.createObjectURL(outBlob);
        downloadLink.href = outUrl;
        downloadLink.download = currentFile.name.replace(/\.[^/.]+$/, '') + '-compressed.pdf';
        downloadLink.textContent = 'Download compressed PDF';
        downloadLink.style.display = 'inline-block';
        sizeInfo.textContent = `Original: ${(currentFile.size / 1024).toFixed(1)} KB ‚Äî Compressed: ${(outBlob.size / 1024).toFixed(1)} KB`;
        log(`Done. Original ${(currentFile.size / 1024).toFixed(1)} KB, Compressed ${(outBlob.size / 1024).toFixed(1)} KB`);
        setProgress(1);
      } catch (saveErr) {
        log('Failed to save compressed PDF: ' + saveErr.message);
      } finally {
        cancelBtn.style.display = 'none';
        startBtn.style.display = 'inline-block';
      }
    });

    // Cancel handling
    cancelBtn.addEventListener('click', () => {
      controller.cancel = true;
      log('Cancel requested ‚Äî stopping as soon as possible.');
      cancelBtn.style.display = 'none';
    });

    // Basic memory safety: attempt to revoke object URLs on unload
    window.addEventListener('unload', () => {
      // nothing to revoke centrally here ‚Äî created blobs are in downloadLink href only
    });

  </script>
</body>

</html>
